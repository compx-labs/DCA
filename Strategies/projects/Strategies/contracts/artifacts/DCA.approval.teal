#pragma version 9

// This TEAL was generated by TEALScript v0.100.2
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *call_DeleteApplication *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication(address,uint64,address)void
*abi_route_createApplication:
	// swapManagerAccount: address
	txna ApplicationArgs 3
	dup
	len
	int 32
	==

	// argument 0 (swapManagerAccount) for createApplication must be a address
	assert

	// swapToken: uint64
	txna ApplicationArgs 2
	btoi

	// orchestratorAddress: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 2 (orchestratorAddress) for createApplication must be a address
	assert

	// execute createApplication(address,uint64,address)void
	callsub createApplication
	int 1
	return

// createApplication(orchestratorAddress: Address, swapToken: uint64, swapManagerAccount: Address): void
createApplication:
	proto 3 0

	// contracts/DCA.algo.ts:23
	// this.swappedTokenBalance.value = 0
	byte 0x73776170706564546f6b656e42616c616e6365 // "swappedTokenBalance"
	int 0
	app_global_put

	// contracts/DCA.algo.ts:24
	// this.mbr.value = 0
	byte 0x6d6272 // "mbr"
	int 0
	app_global_put

	// contracts/DCA.algo.ts:25
	// this.lastUpdated.value = globals.latestTimestamp
	byte 0x6c61737455706461746564 // "lastUpdated"
	global LatestTimestamp
	app_global_put

	// contracts/DCA.algo.ts:26
	// this.orchestratorAddress.value = orchestratorAddress
	byte 0x6f7263686573747261746f7241646472657373 // "orchestratorAddress"
	frame_dig -1 // orchestratorAddress: Address
	app_global_put

	// contracts/DCA.algo.ts:27
	// this.userAddress.value = this.txn.sender
	byte 0x7573657241646472657373 // "userAddress"
	txn Sender
	app_global_put

	// contracts/DCA.algo.ts:28
	// this.SwapToTokenId.value = swapToken
	byte 0x53776170546f546f6b656e4964 // "SwapToTokenId"
	frame_dig -2 // swapToken: uint64
	app_global_put

	// contracts/DCA.algo.ts:29
	// this.swapAmount.value = 0
	byte 0x73776170416d6f756e74 // "swapAmount"
	int 0
	app_global_put

	// contracts/DCA.algo.ts:30
	// this.swapManagerAccount.value = swapManagerAccount
	byte 0x737761704d616e616765724163636f756e74 // "swapManagerAccount"
	frame_dig -3 // swapManagerAccount: Address
	app_global_put
	retsub

// deleteApplication()void
*abi_route_deleteApplication:
	// execute deleteApplication()void
	callsub deleteApplication
	int 1
	return

// deleteApplication(): void
deleteApplication:
	proto 0 0

	// contracts/DCA.algo.ts:35
	// assert(this.txn.sender === this.userAddress.value, "Only user can delete application")
	txn Sender
	byte 0x7573657241646472657373 // "userAddress"
	app_global_get
	==

	// Only user can delete application
	assert
	retsub

// optInToAsset(uint64)void
*abi_route_optInToAsset:
	// asset: uint64
	txna ApplicationArgs 1
	btoi

	// execute optInToAsset(uint64)void
	callsub optInToAsset
	int 1
	return

// optInToAsset(asset: AssetID): void
optInToAsset:
	proto 1 0

	// contracts/DCA.algo.ts:39
	// assert(this.txn.sender === this.userAddress.value, "Only user can opt contract into asset")
	txn Sender
	byte 0x7573657241646472657373 // "userAddress"
	app_global_get
	==

	// Only user can opt contract into asset
	assert

	// contracts/DCA.algo.ts:41
	// sendAssetTransfer({
	//       xferAsset: asset,
	//       assetAmount: 0,
	//       assetReceiver: this.app.address,
	//       sender: this.app.address,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/DCA.algo.ts:42
	// xferAsset: asset
	frame_dig -1 // asset: AssetID
	itxn_field XferAsset

	// contracts/DCA.algo.ts:43
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// contracts/DCA.algo.ts:44
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/DCA.algo.ts:45
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// addMBR(pay,uint64)void
*abi_route_addMBR:
	// quantity: uint64
	txna ApplicationArgs 1
	btoi

	// payTxn: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==

	// argument 1 (payTxn) for addMBR must be a pay transaction
	assert

	// execute addMBR(pay,uint64)void
	callsub addMBR
	int 1
	return

// addMBR(payTxn: PayTxn, quantity: uint64): void
addMBR:
	proto 2 0

	// contracts/DCA.algo.ts:50
	// assert(this.txn.sender == this.userAddress.value, "Only user can add MBR")
	txn Sender
	byte 0x7573657241646472657373 // "userAddress"
	app_global_get
	==

	// Only user can add MBR
	assert

	// contracts/DCA.algo.ts:52
	// verifyPayTxn(payTxn, {
	//       sender: this.userAddress.value,
	//       receiver: this.app.address,
	//       amount: quantity,
	//     })
	// verify sender
	frame_dig -1 // payTxn: PayTxn
	gtxns Sender
	byte 0x7573657241646472657373 // "userAddress"
	app_global_get
	==

	// transaction verification failed: {"txn":"payTxn","field":"sender","expected":"this.userAddress.value"}
	assert

	// verify receiver
	frame_dig -1 // payTxn: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payTxn","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // payTxn: PayTxn
	gtxns Amount
	frame_dig -2 // quantity: uint64
	==

	// transaction verification failed: {"txn":"payTxn","field":"amount","expected":"quantity"}
	assert

	// contracts/DCA.algo.ts:57
	// this.mbr.value += payTxn.amount
	byte 0x6d6272 // "mbr"
	app_global_get
	frame_dig -1 // payTxn: PayTxn
	gtxns Amount
	+
	byte 0x6d6272 // "mbr"
	swap
	app_global_put

	// contracts/DCA.algo.ts:58
	// this.lastUpdated.value = globals.latestTimestamp
	byte 0x6c61737455706461746564 // "lastUpdated"
	global LatestTimestamp
	app_global_put
	retsub

// setSwapParams(uint64,uint64)void
*abi_route_setSwapParams:
	// SwapToTokenId: uint64
	txna ApplicationArgs 2
	btoi

	// swapAmount: uint64
	txna ApplicationArgs 1
	btoi

	// execute setSwapParams(uint64,uint64)void
	callsub setSwapParams
	int 1
	return

// setSwapParams(swapAmount: uint64, SwapToTokenId: uint64): void
setSwapParams:
	proto 2 0

	// contracts/DCA.algo.ts:62
	// assert(this.txn.sender == this.userAddress.value, "Only user can set swap params")
	txn Sender
	byte 0x7573657241646472657373 // "userAddress"
	app_global_get
	==

	// Only user can set swap params
	assert

	// contracts/DCA.algo.ts:64
	// this.swapAmount.value = swapAmount
	byte 0x73776170416d6f756e74 // "swapAmount"
	frame_dig -1 // swapAmount: uint64
	app_global_put

	// contracts/DCA.algo.ts:65
	// this.SwapToTokenId.value = SwapToTokenId
	byte 0x53776170546f546f6b656e4964 // "SwapToTokenId"
	frame_dig -2 // SwapToTokenId: uint64
	app_global_put

	// contracts/DCA.algo.ts:67
	// this.lastUpdated.value = globals.latestTimestamp
	byte 0x6c61737455706461746564 // "lastUpdated"
	global LatestTimestamp
	app_global_put
	retsub

// updateSwapManagerAccount(address)void
*abi_route_updateSwapManagerAccount:
	// swapManagerAccount: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (swapManagerAccount) for updateSwapManagerAccount must be a address
	assert

	// execute updateSwapManagerAccount(address)void
	callsub updateSwapManagerAccount
	int 1
	return

// updateSwapManagerAccount(swapManagerAccount: Address): void
updateSwapManagerAccount:
	proto 1 0

	// contracts/DCA.algo.ts:71
	// assert(this.txn.sender == this.orchestratorAddress.value, "Only orchestrator can update swap manager account")
	txn Sender
	byte 0x6f7263686573747261746f7241646472657373 // "orchestratorAddress"
	app_global_get
	==

	// Only orchestrator can update swap manager account
	assert

	// contracts/DCA.algo.ts:73
	// this.swapManagerAccount.value = swapManagerAccount
	byte 0x737761704d616e616765724163636f756e74 // "swapManagerAccount"
	frame_dig -1 // swapManagerAccount: Address
	app_global_put

	// contracts/DCA.algo.ts:75
	// this.lastUpdated.value = globals.latestTimestamp
	byte 0x6c61737455706461746564 // "lastUpdated"
	global LatestTimestamp
	app_global_put
	retsub

// initiateSwap()void
*abi_route_initiateSwap:
	// execute initiateSwap()void
	callsub initiateSwap
	int 1
	return

// initiateSwap(): void
initiateSwap:
	proto 0 0

	// contracts/DCA.algo.ts:79
	// assert(this.txn.sender == this.userAddress.value, "Only user can initiate swap")
	txn Sender
	byte 0x7573657241646472657373 // "userAddress"
	app_global_get
	==

	// Only user can initiate swap
	assert

	// contracts/DCA.algo.ts:80
	// assert(this.app.address.balance > 0, "Insufficient balance")
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	int 0
	>

	// Insufficient balance
	assert

	// contracts/DCA.algo.ts:81
	// assert(this.swapAmount.value > 0, "Swap amount not set")
	byte 0x73776170416d6f756e74 // "swapAmount"
	app_global_get
	int 0
	>

	// Swap amount not set
	assert

	// contracts/DCA.algo.ts:82
	// assert(this.SwapToTokenId.value > 0, "Swap token not set")
	byte 0x53776170546f546f6b656e4964 // "SwapToTokenId"
	app_global_get
	int 0
	>

	// Swap token not set
	assert

	// contracts/DCA.algo.ts:84
	// sendPayment({
	//       amount: this.swapAmount.value,
	//       sender: this.app.address,
	//       receiver: this.swapManagerAccount.value,
	//       note: "Swap requested: to, amount: " + this.SwapToTokenId.value + ", " + this.swapAmount.value,
	//     })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts/DCA.algo.ts:85
	// amount: this.swapAmount.value
	byte 0x73776170416d6f756e74 // "swapAmount"
	app_global_get
	itxn_field Amount

	// contracts/DCA.algo.ts:86
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/DCA.algo.ts:87
	// receiver: this.swapManagerAccount.value
	byte 0x737761704d616e616765724163636f756e74 // "swapManagerAccount"
	app_global_get
	itxn_field Receiver

	// contracts/DCA.algo.ts:88
	// note: "Swap requested: to, amount: " + this.SwapToTokenId.value + ", " + this.swapAmount.value
	byte 0x53776170207265717565737465643a20746f2c20616d6f756e743a20 // "Swap requested: to, amount: "
	byte 0x53776170546f546f6b656e4964 // "SwapToTokenId"
	app_global_get
	concat
	byte 0x2c20 // ", "
	concat
	byte 0x73776170416d6f756e74 // "swapAmount"
	app_global_get
	concat
	itxn_field Note

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/DCA.algo.ts:91
	// this.lastUpdated.value = globals.latestTimestamp
	byte 0x6c61737455706461746564 // "lastUpdated"
	global LatestTimestamp
	app_global_put
	retsub

// receiveSwapAndSendOn(axfer,uint64)void
*abi_route_receiveSwapAndSendOn:
	// quantity: uint64
	txna ApplicationArgs 1
	btoi

	// axferTxn: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int axfer
	==

	// argument 1 (axferTxn) for receiveSwapAndSendOn must be a axfer transaction
	assert

	// execute receiveSwapAndSendOn(axfer,uint64)void
	callsub receiveSwapAndSendOn
	int 1
	return

// receiveSwapAndSendOn(axferTxn: AssetTransferTxn, quantity: uint64): void
receiveSwapAndSendOn:
	proto 2 0

	// contracts/DCA.algo.ts:95
	// assert(this.txn.sender == this.swapManagerAccount.value, "Only swap manager can send swap tokens")
	txn Sender
	byte 0x737761704d616e616765724163636f756e74 // "swapManagerAccount"
	app_global_get
	==

	// Only swap manager can send swap tokens
	assert

	// contracts/DCA.algo.ts:97
	// verifyAssetTransferTxn(axferTxn, {
	//       sender: this.swapManagerAccount.value,
	//       assetReceiver: this.app.address,
	//       assetAmount: quantity,
	//       xferAsset: AssetID.fromUint64(this.SwapToTokenId.value),
	//       note: axferTxn.xferAsset.id.toString() + ", " + axferTxn.assetAmount.toString(),
	//     })
	// verify sender
	frame_dig -1 // axferTxn: AssetTransferTxn
	gtxns Sender
	byte 0x737761704d616e616765724163636f756e74 // "swapManagerAccount"
	app_global_get
	==

	// transaction verification failed: {"txn":"axferTxn","field":"sender","expected":"this.swapManagerAccount.value"}
	assert

	// verify assetReceiver
	frame_dig -1 // axferTxn: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"axferTxn","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify assetAmount
	frame_dig -1 // axferTxn: AssetTransferTxn
	gtxns AssetAmount
	frame_dig -2 // quantity: uint64
	==

	// transaction verification failed: {"txn":"axferTxn","field":"assetAmount","expected":"quantity"}
	assert

	// verify xferAsset
	frame_dig -1 // axferTxn: AssetTransferTxn
	gtxns XferAsset
	byte 0x53776170546f546f6b656e4964 // "SwapToTokenId"
	app_global_get
	==

	// transaction verification failed: {"txn":"axferTxn","field":"xferAsset","expected":"AssetID.fromUint64(this.SwapToTokenId.value)"}
	assert

	// verify note
	frame_dig -1 // axferTxn: AssetTransferTxn
	gtxns Note
	frame_dig -1 // axferTxn: AssetTransferTxn
	gtxns XferAsset
	callsub *itoa
	byte 0x2c20 // ", "
	concat
	frame_dig -1 // axferTxn: AssetTransferTxn
	gtxns AssetAmount
	callsub *itoa
	concat
	==

	// transaction verification failed: {"txn":"axferTxn","field":"note","expected":"axferTxn.xferAsset.id.toString() + \", \" + axferTxn.assetAmount.toString()"}
	assert

	// contracts/DCA.algo.ts:105
	// this.swappedTokenBalance.value += axferTxn.assetAmount
	byte 0x73776170706564546f6b656e42616c616e6365 // "swappedTokenBalance"
	app_global_get
	frame_dig -1 // axferTxn: AssetTransferTxn
	gtxns AssetAmount
	+
	byte 0x73776170706564546f6b656e42616c616e6365 // "swappedTokenBalance"
	swap
	app_global_put

	// contracts/DCA.algo.ts:106
	// this.lastUpdated.value = globals.latestTimestamp
	byte 0x6c61737455706461746564 // "lastUpdated"
	global LatestTimestamp
	app_global_put
	retsub

// sendSwappedTokens(address)void
*abi_route_sendSwappedTokens:
	// sendToAddress: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (sendToAddress) for sendSwappedTokens must be a address
	assert

	// execute sendSwappedTokens(address)void
	callsub sendSwappedTokens
	int 1
	return

// sendSwappedTokens(sendToAddress: Address): void
sendSwappedTokens:
	proto 1 0

	// contracts/DCA.algo.ts:110
	// assert(this.txn.sender == this.orchestratorAddress.value, "Only orchestrator can send swapped tokens to nominated accounts")
	txn Sender
	byte 0x6f7263686573747261746f7241646472657373 // "orchestratorAddress"
	app_global_get
	==

	// Only orchestrator can send swapped tokens to nominated accounts
	assert

	// contracts/DCA.algo.ts:111
	// assert(this.swappedTokenBalance.value > 0, "Insufficient swapped tokens")
	byte 0x73776170706564546f6b656e42616c616e6365 // "swappedTokenBalance"
	app_global_get
	int 0
	>

	// Insufficient swapped tokens
	assert

	// contracts/DCA.algo.ts:113
	// sendAssetTransfer({
	//       sender: this.app.address,
	//       assetReceiver: sendToAddress,
	//       assetAmount: this.swappedTokenBalance.value,
	//       xferAsset: AssetID.fromUint64(this.SwapToTokenId.value),
	//       note: "Swapped tokens sent to " + sendToAddress,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/DCA.algo.ts:114
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/DCA.algo.ts:115
	// assetReceiver: sendToAddress
	frame_dig -1 // sendToAddress: Address
	itxn_field AssetReceiver

	// contracts/DCA.algo.ts:116
	// assetAmount: this.swappedTokenBalance.value
	byte 0x73776170706564546f6b656e42616c616e6365 // "swappedTokenBalance"
	app_global_get
	itxn_field AssetAmount

	// contracts/DCA.algo.ts:117
	// xferAsset: AssetID.fromUint64(this.SwapToTokenId.value)
	byte 0x53776170546f546f6b656e4964 // "SwapToTokenId"
	app_global_get
	itxn_field XferAsset

	// contracts/DCA.algo.ts:118
	// note: "Swapped tokens sent to " + sendToAddress
	byte 0x5377617070656420746f6b656e732073656e7420746f20 // "Swapped tokens sent to "
	frame_dig -1 // sendToAddress: Address
	concat
	itxn_field Note

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/DCA.algo.ts:121
	// this.swappedTokenBalance.value = 0
	byte 0x73776170706564546f6b656e42616c616e6365 // "swappedTokenBalance"
	int 0
	app_global_put

	// contracts/DCA.algo.ts:122
	// this.lastUpdated.value = globals.latestTimestamp
	byte 0x6c61737455706461746564 // "lastUpdated"
	global LatestTimestamp
	app_global_put
	retsub

*create_NoOp:
	method "createApplication(address,uint64,address)void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	method "optInToAsset(uint64)void"
	method "addMBR(pay,uint64)void"
	method "setSwapParams(uint64,uint64)void"
	method "updateSwapManagerAccount(address)void"
	method "initiateSwap()void"
	method "receiveSwapAndSendOn(axfer,uint64)void"
	method "sendSwappedTokens(address)void"
	txna ApplicationArgs 0
	match *abi_route_optInToAsset *abi_route_addMBR *abi_route_setSwapParams *abi_route_updateSwapManagerAccount *abi_route_initiateSwap *abi_route_receiveSwapAndSendOn *abi_route_sendSwappedTokens

	// this contract does not implement the given ABI method for call NoOp
	err

*call_DeleteApplication:
	method "deleteApplication()void"
	txna ApplicationArgs 0
	match *abi_route_deleteApplication

	// this contract does not implement the given ABI method for call DeleteApplication
	err

*intToAscii:
	proto 1 1
	byte 0x30313233343536373839 // "0123456789"
	frame_dig -1 // i: uint64
	int 1
	extract3
	retsub
	

*itoa:
	proto 1 1
	frame_dig -1 // i: uint64
	int 0
	==
	bz *itoa_if_end
	byte 0x30
	retsub

*itoa_if_end:
	frame_dig -1 // i: uint64
	int 10
	/
	int 0
	>
	bz *itoa_ternary_false
	frame_dig -1 // i: uint64
	int 10
	/
	callsub *itoa
	b *itoa_ternary_end

*itoa_ternary_false:
	byte 0x // ""

*itoa_ternary_end:
	frame_dig -1 // i: uint64
	int 10
	%
	callsub *intToAscii
	concat
	retsub